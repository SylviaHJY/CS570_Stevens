package JY_hw5;

import java.util.Random;
import java.util.Stack;

/**
 * Assignment : 5
 * Name: Jiayin Huang
 * CWID: 10477088
 * Course: CS-570
 */

public class Treap<E extends Comparable<E>> {
  private Random priorityGenerator;
  private Node<E> root;

  /**
   <p>Treap() creates an empty treap. Initialize priorityGenerator using new Random()</p>
   * @param
   *  @author: Jiayin Huang
   *  @date: 11/12/2022
   */
  public Treap(){
    this.priorityGenerator = new Random();
    this.root = null;
  }

  /**
   <p>Treap(long seed) creates an empty treap and initializes priorityGenerator using new Random(seed).</p>
   * @param seed Long Integer. To generate the random generator.
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  public Treap(long seed){
    this.priorityGenerator = new Random(seed);
    this.root = null;
  }

  /**
   <p>To insert the given element into the tree, create a new node containing key as its data and
   a random priority generated by priorityGenerator. The method returns true, if a node with the
   key was successfully added to the treap. If there is already a node containing the given
   key, the method returns false and does not modify the treap.
   </p>
   <p>have add(E key) call the add(E key, int priority) method once it has generated the ran-dom
   priority. Thus all the “work” is performed by the latter method.</p>
   * @param
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  public boolean add(E key){
    if(key == null) {
      throw new NullPointerException("Key is not exit!");
    }else{
      int priority = priorityGenerator.nextInt();
      return add(key,priority);
    }
  }

  /**
   <p>Add a node with key and priority into the treap.</p>
   * @param key and priority;
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  public boolean add(E key,int priority){
    if(key == null){
      throw new NullPointerException("Invalid key value");
    }
    Node<E> newNode = new Node<E>(key,priority);
    Stack<Node<E>> reheapStack = new Stack<>();

    if(root == null){
      this.root = newNode;
      return true;
    }

    Node<E> current = this.root;
    Node<E> parent = null;
    while(current != null){
      parent = current;
      if(current.data.compareTo(key) > 0){
        reheapStack.push(parent);
        current = current.left;
      }else if(current.data.compareTo(key) < 0){
        reheapStack.push(parent);
        current = current.right;
      }else if(newNode.data.compareTo(current.data) == 0){
        return false;
      }
    }
    if(key.compareTo(parent.data) > 0){
      parent.right = newNode;
    }else{
      parent.left = newNode;
    }
    reheap(newNode,reheapStack);
    return true;
  }

  /**
   * helper function - reheap (with appropriate param-eters that should include the stack) to restore the heap invariant.
   * @param stack
   * @return void
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  private void reheap(Node<E>node, Stack<Node<E>> stack){
    if(stack.isEmpty()){
      this.root = node;
    }else if(stack.peek().priority > node.priority){
      return;
    }else{
      if(stack.peek().right == node){
        Node<E> tempNode = stack.pop();
        tempNode.rotateLeft();
        if(!stack.isEmpty()){
          if(stack.peek().right == tempNode){
            stack.peek().right = node;
          }else{
            stack.peek().left = node;
          }
        }
      }else{
        Node<E> tempNode1 = stack.pop();
        tempNode1.rotateRight();
        if(!stack.isEmpty()){
          if(stack.peek().right == tempNode1){
            stack.peek().right = node;
          }else{
            stack.peek().left = node;
          }
        }
      }
      reheap(node,stack);
    }
  }

  /**
   <p>Finds a node with the given key in the treap rooted at
   root and returns true if it finds it and false otherwise</p>
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  private boolean find(Node<E>root, E key){
    Node<E> currentRoot = root;
    while(true){
      if(currentRoot != null){
        if(key.compareTo(currentRoot.data) == 0){
          return true;
        }else if(key.compareTo(currentRoot.data) < 0){
          currentRoot = currentRoot.left;
        }else if(key.compareTo(currentRoot.data) > 0){
          currentRoot = currentRoot.right;
        }
      }else{
        return false;
      }
    }
  }

  /**
   <p>Finds a node with the given key in the treap and returns true if it finds it
   and false otherwise.</p>
   * @param key
   * @return
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  public boolean find(E key){
    if(key == null){
      throw new NullPointerException("Key is invalid value");
    }
    Node<E> r = root;
    return find(r,key);
  }

  /**
   <p>boolean delete(E key) deletes the node with the given key from the treap and returns true. If the
   key was not found, the method does not modify the treap and returns false. In order to remove
   a node trickle it down using rotation until it becomes a leaf and then remove it.</p>
   * @param key
   * @return true or false
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  public boolean delete(E key){
    if(find(key) == false){
      return false;
    }
    if(root == null){
      return false;
    }
    this.root = delete(this.root,key);
    return true;
  }

  /**
   * helper function for delete
   */
  private Node<E> delete(Node<E> tempNode, E tempKey){
    if(tempNode != null){
      if(tempKey.compareTo(tempNode.data) < 0){
        tempNode.left = delete(tempNode.left,tempKey);
      }else if(tempKey.compareTo(tempNode.data) > 0){
        tempNode.right = delete(tempNode.right,tempKey);
      }else{
        if(tempNode.left == null){
          tempNode =  tempNode.right;
        }else if(tempNode.right  == null){
         tempNode =  tempNode.left;
        }else{
          if(tempNode.left.priority > tempNode.right.priority){
            tempNode = tempNode.rotateRight();
            tempNode.right = delete(tempNode.right,tempKey);
          }else{
            tempNode = tempNode.rotateLeft();
            tempNode.left = delete(tempNode.left,tempKey);
          }
        }
      }
    }
    return tempNode;
  }

  /**
   <p>public String toString(): Carries out a preorder traversal of the tree and returns a represen-tation
   of the nodes as a string. Each node with key k and priority p, left child l, and right child r is
   represented as the string [k, p] (l) (r). If the left child does not exist, the string representation is
   [k, p] null (r). Analogously, if there is no right child, the string representa-tion of the tree is [k, p]
   (l) null. </p>
   <p>Variables l, k, and p must be replaced by its corresponding string representation, as
   defined by the toString() method of the corresponding object</p>
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    return preOrderTraverse(root,1,sb);
  }
  /**
   <p>Help method of toString().</p>
   <p>Using pre-order traverse.</p>
   * @param root Local root.
   * @param depth The depth of local root. To make spaces.
   * @return The String of pre-order traverse.
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  private String preOrderTraverse(Node<E> root, int depth, StringBuilder sb){
    for(int i = 1; i < depth; i++){
      sb.append(" ");
    }
    if(root ==null){
      sb.append("null\n");
    }else{
      sb.append(root.toString() + "\n");
      preOrderTraverse(root.left,depth + 1,sb);
      preOrderTraverse(root.right,depth + 1,sb);
    }
    return sb.toString();
  }

/**
   <p>Create a private static inner class Node<E> of the Treap class</p>
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
  private class Node<E>{
    public E data;
    public int priority;
    public Node<E> left;
    public Node<E> right;

    /**
     <p>Constructor with data & priority.</p>
     * @param data The data.
     * @param priority The priority.
     * @author: Jiayin Huang
     * @date: 11/12/2022
     */
    public Node(E data, int priority){
      if(data == null){
        throw new NullPointerException("Invalid data, data is null");
      }
      this.left = null;
      this.right = null;
      this.data = data;
      this.priority =priority;
    }

    /**
     <p>rotateRight() performs a right rotation according to Figure 2, returning a reference to the
     root of the result. The root node in the figure corresponds to this node. Update the data
     and priority attributes as well as the left and right pointers of the involved nodes
     accordingly.</p>
     * @param
     * @return The local root after rotate.
     * @author: Jiayin Huang
     * @date: 11/12/2022
     */
    Node<E> rotateRight(){
      if(this.left == null){
        throw new NullPointerException("Unable to rotate to right.");
      }
//      Node<E> temp = new Node<E>(this.data, this.priority);
//      temp.left = this.left.right;
//      temp.right = this.right;
//      this.priority = this.left.priority;
//      this.data = this.left.data;
//      this.left = this.left.left;
//      this.right = temp;
//      return this;
      Node<E> temp = this.left;
      Node<E> R = temp.right;
      temp.right = this;
      this.left = R;
      return temp;
    }

    /**
     <p>rotateLeft() performs a left rotation according to Figure 2 returning a reference to the root
     of the result. The root node in the figure corresponds to this node. Update the attributes
     of the nodes accordingly.</p>
     * @param
     * @return The local root after rotate.
     * @author: Jiayin Huang
     * @date: 11/12/2022
     */
    Node<E> rotateLeft(){
      if(this.right == null){
        throw new NullPointerException("Unable to rotate to left.");
      }
//      Node<E> temp = new Node<E>(this.data, this.priority);
//      temp.left = this.left;
//      temp.right = this.right.left;
//      this.priority = this.right.priority;
//      this.data = this.right.data;
//      this.left = temp;
//      this.right = this.right.right;
//      return this;
      Node<E> temp = this.right;
      Node<E> L = temp.left;
      temp.left = this;
      this.right = L;
      return temp;
    }

    /**
     * Translates the node to a string
     * @return String
     */
  @Override
  public String toString() {
    return "Node{" +
            "data=" + data +
            ", priority=" + priority +
            '}';
  }
}

  /**
   * <p>Constructed tests for basic functions and the example Treap</p>
   * @param args
   * @author: Jiayin Huang
   * @date: 11/12/2022
   */
    public static void main(String[] args) {
      Treap testTree = new Treap<Integer>();
      testTree.add(4, 19);
      testTree.add(2, 31);
      testTree.add(6, 70);
      testTree.add(1, 84);
      testTree.add(3, 12);
      testTree.add(5, 83);
      testTree.add(7, 26);
      System.out.println(testTree.toString());

      //Test Find
      System.out.println("Now let's find node 5: " + testTree.find(5));
      System.out.println("Now let's find node 10: " + testTree.find(10));


      //Test delete
      System.out.println("Now let's delete node 10: " + testTree.delete(10));
      System.out.println("Now let's delete node 1: " + testTree.delete(1));
      System.out.println(testTree.toString());
      System.out.println();
      System.out.println("Now let's delete node 7: " + testTree.delete(7));
      System.out.println(testTree.toString());
    }
}

